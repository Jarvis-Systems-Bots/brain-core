<?php

declare(strict_types=1);

namespace BrainCore\Includes\Commands;

use BrainCore\Archetypes\IncludeArchetype;
use BrainCore\Attributes\Purpose;
use BrainCore\Compilation\BrainCLI;
use BrainCore\Compilation\Operator;
use BrainCore\Compilation\Store;
use BrainCore\Compilation\Tools\BashTool;
use BrainNode\Agents\DocumentationMaster;
use BrainNode\Agents\ExploreMaster;
use BrainNode\Mcp\VectorMemoryMcp;

#[Purpose('The /init-vector command automates project knowledge base setup via parallel agent execution.')]
class InitVectorInclude extends IncludeArchetype
{
    protected function handle(): void
    {
        // Iron Rules - Compact
        $this->rule('parallel-execution')->critical()
            ->text('Launch INDEPENDENT areas in PARALLEL (multiple Task calls in single response)')
            ->why('Maximizes throughput, reduces total initialization time')
            ->onViolation('Group independent areas, launch simultaneously');

        $this->rule('brain-docs-then-document-master')->critical()
            ->text('Use brain docs for INDEX, then DocumentationMaster agents to ANALYZE content')
            ->why('brain docs = metadata index, DocumentationMaster = content analysis + vector storage')
            ->onViolation('brain docs → group docs → parallel DocumentationMaster agents');

        $this->rule('dense-storage')->critical()
            ->text('Store compact JSON-like format: {key:value} pairs, no verbose prose')
            ->why('Maximizes information density, improves vector search relevance')
            ->onViolation('Reformat to: path|type|files|classes|patterns|deps');

        $this->rule('memory-before-after')->high()
            ->text('search_memories BEFORE exploring, store_memory AFTER')
            ->why('Context continuity between agents')
            ->onViolation('Add mandatory memory operations');

        $this->rule('no-questions')->high()
            ->text('Fully automated - no user prompts')
            ->why('Batch initialization workflow')
            ->onViolation('Proceed autonomously');

        // Phase 1: Memory Status Check
        $this->guideline('phase1-status')
            ->goal('Check memory state, determine fresh vs augment mode')
            ->example()
            ->phase(VectorMemoryMcp::call('get_memory_stats', '{}'))
            ->phase(Store::as('MEM', '{total, categories}'))
            ->phase(Operator::if('$MEM.total === 0', 'Fresh init', 'Augment existing'));

        // Phase 2: Structure Discovery (Quick)
        $this->guideline('phase2-structure')
            ->goal('Quick structure scan to identify areas for parallel exploration')
            ->example()
            ->phase(
                ExploreMaster::call(
                    Operator::task([
                        'QUICK SCAN ONLY - identify directories, not deep analysis',
                        'Glob("*") → list root directories',
                        'Classify: code(src/app), tests, config, docs(.docs), build, deps',
                        'Output JSON: {areas: [{path, type, priority}]}',
                    ]),
                    Operator::output('{areas: [{path, type, priority: high|medium|low}]}'),
                    Store::as('AREAS')
                )
            );

        // Phase 3: PARALLEL Exploration Batches
        $this->guideline('phase3-parallel-code')
            ->goal('PARALLEL: Launch code exploration agents simultaneously')
            ->example()
            ->phase('BATCH 1 - Code Areas (LAUNCH IN PARALLEL):')
            ->do([
                ExploreMaster::call(
                    Operator::task([
                        'Area: src/ or app/',
                        'Thoroughness: very thorough',
                        'BEFORE: search_memories("src code architecture", 3)',
                        'DO: Glob(**/*.php), Grep(class|function|namespace)',
                        'EXTRACT: {path|files|classes|namespaces|patterns|deps}',
                        'AFTER: store_memory(compact_json, "architecture", ["init-vector","src"])',
                    ]),
                    Operator::output('{path:"src",files:N,classes:N,key_patterns:[]}')
                ),
                ExploreMaster::call(
                    Operator::task([
                        'Area: tests/',
                        'Thoroughness: medium',
                        'BEFORE: search_memories("tests structure", 3)',
                        'DO: Glob(**/*Test.php), identify test framework',
                        'EXTRACT: {path|test_files|coverage_areas|framework}',
                        'AFTER: store_memory(compact_json, "architecture", ["init-vector","tests"])',
                    ]),
                    Operator::output('{path:"tests",files:N,framework:str}')
                ),
            ])
            ->phase('NOTE: Both agents run SIMULTANEOUSLY via parallel Task calls');

        // Phase 3b: Documentation - Index + Analyze
        $this->guideline('phase3-documentation')
            ->goal('Index .docs/ via brain docs, then analyze content via DocumentationMaster agents')
            ->example()
            ->phase('STEP 1 - Get documentation index:')
            ->do([
                BashTool::call(BrainCLI::DOCS),
                Store::as('DOCS_INDEX', '[{path, name, description, type}]'),
            ])
            ->phase('STEP 2 - Adaptive batching based on doc count:')
            ->do([
                Operator::if('docs_count <= 3', 'Single DocumentationMaster for all'),
                Operator::if('docs_count 4-8', '2 DocumentationMaster agents in parallel'),
                Operator::if('docs_count 9-15', '3 DocumentationMaster agents in parallel'),
                Operator::if('docs_count > 15', 'Batch by type (guide, api, concept, etc.)'),
            ])
            ->phase('STEP 3 - PARALLEL DocumentationMaster agents (example for 6 docs):')
            ->do([
                DocumentationMaster::call(
                    Operator::task([
                        'Docs batch: [{path1}, {path2}, {path3}]',
                        'Read each doc via Read tool',
                        'EXTRACT per doc: {name|type|key_concepts|related_to}',
                        'AFTER: store_memory(compact_json, "learning", ["init-vector","docs","{type}"])',
                    ]),
                    Operator::output('{docs_analyzed:3,topics:[]}')
                ),
                DocumentationMaster::call(
                    Operator::task([
                        'Docs batch: [{path4}, {path5}, {path6}]',
                        'Read each doc via Read tool',
                        'EXTRACT per doc: {name|type|key_concepts|related_to}',
                        'AFTER: store_memory(compact_json, "learning", ["init-vector","docs","{type}"])',
                    ]),
                    Operator::output('{docs_analyzed:3,topics:[]}')
                ),
            ])
            ->phase('NOTE: Each doc → separate memory entry for precise vector search');

        // Phase 3c: Config & Build (PARALLEL)
        $this->guideline('phase3-parallel-config')
            ->goal('PARALLEL: Config and build areas simultaneously')
            ->example()
            ->phase('BATCH 2 - Config/Build (LAUNCH IN PARALLEL):')
            ->do([
                ExploreMaster::call(
                    Operator::task([
                        'Area: config/',
                        'Thoroughness: quick',
                        'DO: Glob(config/*.php), extract key names',
                        'EXTRACT: {configs:[names],env_vars:[],services:[]}',
                        'AFTER: store_memory(compact_json, "architecture", ["init-vector","config"])',
                    ]),
                    Operator::output('{path:"config",configs:[]}')
                ),
                ExploreMaster::call(
                    Operator::task([
                        'Area: build/CI files',
                        'Thoroughness: quick',
                        'DO: Find .github/, docker*, Makefile, composer.json, package.json',
                        'EXTRACT: {ci:bool,docker:bool,deps:{php:[],js:[]}}',
                        'AFTER: store_memory(compact_json, "architecture", ["init-vector","build"])',
                    ]),
                    Operator::output('{ci:bool,docker:bool,deps:{}}')
                ),
            ]);

        // Phase 4: Cross-Area Synthesis
        $this->guideline('phase4-synthesis')
            ->goal('Synthesize all findings into project-wide architecture')
            ->example()
            ->phase(VectorMemoryMcp::call('search_memories', '{query: "init-vector", limit: 20, tags: ["init-vector"]}'))
            ->phase(Store::as('ALL_FINDINGS'))
            ->phase(
                VectorMemoryMcp::call('store_memory', '{
                    content: "PROJECT:{type}|AREAS:{list}|STACK:{tech}|PATTERNS:{arch}|DEPS:{graph}",
                    category: "architecture",
                    tags: ["init-vector", "project-wide", "synthesis"]
                }')
            );

        // Phase 5: Completion
        $this->guideline('phase5-complete')
            ->goal('Report completion with metrics')
            ->example()
            ->phase(VectorMemoryMcp::call('get_memory_stats', '{}'))
            ->phase(Operator::output([
                '═══ INIT-VECTOR COMPLETE ═══',
                'Areas: {count} | Memories: {total} | Time: {elapsed}',
                'Parallel batches: 2 | Agents launched: {agent_count}',
                '═══════════════════════════',
            ]));

        // Dense Storage Format
        $this->guideline('storage-format')
            ->text('Compact storage format for maximum vector search relevance')
            ->example('BAD: "The src/ directory contains 150 PHP files organized in MVC pattern..."')->key('verbose')
            ->example('GOOD: "src|150php|MVC|App\\Models,App\\Http|Laravel11|eloquent,routing"')->key('dense')
            ->example('Format: path|files|pattern|namespaces|framework|features')->key('schema');

        // Parallel Execution Pattern
        $this->guideline('parallel-pattern')
            ->text('How to execute agents in parallel')
            ->example()
            ->phase('WRONG: forEach(areas) → sequential, slow')
            ->phase('RIGHT: List multiple Task() calls in single response')
            ->phase('Brain executes all Task() calls simultaneously')
            ->phase('Each agent works independently, stores to memory')
            ->phase('Wait for all to complete, then synthesize');

        // brain docs + DocumentationMaster Integration
        $this->guideline('brain-docs-usage')
            ->text('brain docs for INDEX, DocumentationMaster for CONTENT analysis')
            ->example(BashTool::call(BrainCLI::DOCS))->key('list-all')
            ->example(BashTool::call(BrainCLI::DOCS('keyword1,keyword2')))->key('search')
            ->example('Index returns: path, name, description, type, date, version')->key('fields')
            ->example('Then: DocumentationMaster reads & analyzes actual content')->key('analyze')
            ->example('Each doc → Read → Extract key concepts → store_memory')->key('flow');

        // Error Handling (Compact)
        $this->guideline('errors')
            ->text('Error handling')
            ->example('MCP unavailable → abort, report')->key('memory-fail')
            ->example('Agent timeout → skip area, continue, report in summary')->key('timeout')
            ->example('Empty area → store minimal, proceed')->key('empty');

        // Example: Fresh Init
        $this->guideline('example-fresh')
            ->scenario('Fresh initialization with 8 docs')
            ->example()
            ->phase('1', 'Memory: 0 entries → fresh init')
            ->phase('2', 'Structure scan: 5 areas (src, tests, config, .docs, build)')
            ->phase('3a', 'PARALLEL: ExploreMaster(src/) + ExploreMaster(tests/) → 2 agents')
            ->phase('3b', 'brain docs → 8 docs found → batch into 3+3+2')
            ->phase('3b-parallel', 'PARALLEL: 3x DocumentationMaster agents')
            ->phase('3c', 'PARALLEL: ExploreMaster(config/) + ExploreMaster(build/) → 2 agents')
            ->phase('4', 'Synthesis: search init-vector memories → project-wide summary')
            ->phase('5', 'Complete: 15 memories, 7 agents (4 Explore + 3 DocMaster)');

        // Directive
        $this->guideline('directive')
            ->text('PARALLEL agents! brain docs → DocumentationMaster! Dense storage! Fast init!');
    }
}
